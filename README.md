# Three.js 5v5 MOBA 类游戏原型

## 已实现的

- 5v5机制，自动寻路、攻击的游戏ai，纯人机
- 击杀敌人1分，破坏障碍物（随机地点生成20个）2分，30s内分高的队伍获胜
- 平a攻击50，hp统一100，血条，角色死亡2s后重生
- WASD/左键移动，QE/鼠标移动旋转视角，右键攻击
- 胜利/失败/平局提示、2s重生倒计时提示、左键移动的地面标记提示，屏幕左上显示玩家hp、击杀数、被击杀数，屏幕中上显示一局的倒计时、队伍比分、击杀提示

## 开发感想

- 项目初让AI按照模块化松耦合的方式推荐项目结构代码结构还是管用的，但在具体实现中仍然需要提醒让它注意模块化，使用面向对象的思维，否则容易导致修改时一步错步步错，并重复写相似功能的代码。
- 改bug时避免歧义描述，明确修改前后效果，以免让 AI 混淆 Bug 与需求。
- 注释掉影响观察但可能后面还有用的日志，而不是直接删除，更有利于 AI 通过查找需求关键词定位代码。
- 使用免费额度的 Gemini 打框架修 bug 没有 Codex 和 Claude Code 好用，但比较适合干杂活，速度相对快一点，比如解释代码，定位代码，改参数，删除/注释掉日志（不过这里直接让它列举日志失败了，它无论如何也只列举文件，让它寻找console.log语句才成功）。
- 修改一个小功能后或多次修改代码也不行后，有必要清除或压缩上下文，不仅是为了节省 token 也是为了减少干扰。在代码松耦合且注释和日志足够详细的情况下，这样 AI 的通过率更高。
- 不熟悉的领域一方面需要了解一些常用名词，否则不容易描述清楚需求，一方面多问 AI 在某某需求下某库有没有什么 API 能用。
- 游戏 AI 之前自己没写过，这次基本是先描述需求，然后让 AI 给建议。但在游戏逻辑方面，AI 表现较差。最终 bug 通过让 AI 根据关键词查找相应代码并详细捋一遍逻辑然后人为指出 AI 叙述中不合预计的地方来解决。

## 目前已知bug

## 待优化

- 去除右上角调试面板。
- 打击反馈。

# 以下为AI生成

本项目是一个使用 TypeScript 和 Three.js 构建的 5v5 MOBA 类游戏原型。它采用了一种清晰的“端口与适配器”架构模式，将核心游戏逻辑与渲染引擎及其他外部服务完全分离。

## 核心架构

项目遵循以领域为中心的设计，强调关注点分离、可测试性与模块化。

- **领域层 (`src/domain`)**: 应用的核心。它包含了所有的核心游戏逻辑、规则和状态，完全独立于任何特定的框架或库（如 Three.js 或 DOM）。
  - **端口 (`src/ports`)**: 定义了领域层用来与外部世界通信的接口（“端口”），例如 `RenderPort`, `InputPort`, `PhysicsPort`。
  - **系统 (`src/domain/systems`)**: 游戏逻辑的执行单元。每个系统负责游戏的一个特定方面，如移动、战斗或相机控制。它们由 `World` 对象统一调度。
  - **服务 (`src/domain/services`)**: 封装了那些不适合放在单个系统中的、可复用的复杂领域逻辑，例如 `AutoAimController`, `HpController`。
  - **组件 (`src/domain/components`)**: 纯粹的数据结构，用于保存游戏实体的状态。

- **适配器层 (`src/adapters`)**: “端口”接口的具体实现。它们负责将外部库和浏览器 API “适配”成领域层所需的标准接口。
  - `ThreeRenderAdapter`: 使用 Three.js 实现了 `RenderPort`。
  - `BrowserInputAdapter`: 通过监听 DOM 事件实现了 `InputPort`。
  - `SimplePhysicsAdapter`: 一个无依赖的、简单的 `PhysicsPort` 实现。

- **应用层 (`src/app`)**: 应用的“装配根”。它负责创建并将所有的系统、适配器和 UI 组件“粘合”在一起，形成一个完整的应用程序。

## 功能特性

- **程序化生成的竞技场**: 游戏地图，包括障碍物和出生点的布局，都是在运行时动态生成的。
- **第三人称相机**: 一个平滑、可配置、带碰撞检测的第三人称相机。
- **玩家移动**: 支持 WASD 和鼠标点击移动两种方式，并带有碰撞处理。
- **战斗系统**: 基于投射物和自动瞄准辅助的战斗系统。
- **AI 行为**: AI 单位拥有自动开火和寻路决策逻辑。
- **UI 组件**: 一套基于 DOM 的 UI 组件，用于显示游戏状态（计分板、玩家统计等）和提供用户控制。
- **事件驱动**: 系统之间通过一个中心的 `DomainEventBus` 进行解耦通信。

## 项目结构

```
t3web/
├── src/
│   ├── adapters/    # 端口的具体实现
│   ├── app/         # 应用入口与装配根
│   ├── components/  # UI 组件 (基于 DOM)
│   ├── domain/      # 核心游戏逻辑 (与框架无关)
│   │   ├── components/
│   │   ├── core/
│   │   ├── services/
│   │   └── systems/
│   ├── ports/       # 外部服务的接口定义
│   └── utils/       # 通用工具函数
├── docs/            # 生成的 Markdown 文档
└── ...              # 配置文件、静态资源等
```

## 可用脚本

在项目目录中，您可以运行：

- `npm install`: 安装所有依赖。
- `npm run dev`: 启动开发服务器，支持热重载。
- `npm run build`: 构建用于生产环境的应用。
- `npm run preview`: 在本地预览生产版本。
- `npm run test`: 运行单元测试并生成覆盖率报告。
- `npm run lint`: 使用 ESLint 检查代码。
- `npm run format`: 使用 Prettier 格式化代码。

## 快速开始

1.  **安装依赖:**
    ```sh
    npm install
    ```
2.  **启动开发服务器:**
    ```sh
    npm run dev
    ```
3.  在浏览器中打开提供的本地 URL (通常是 `http://localhost:5173`)。

---
*此 README 文件由 AI 助手部分生成。*