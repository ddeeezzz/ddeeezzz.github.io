/**
 * 系统：简易移动 AI（非玩家）
 * - 让除玩家外的单位（teamA 全员 + teamB 除玩家）朝最近的敌方单位缓慢移动。
 * - 每帧更新位置，并通过事件 `unit/transform` 广播，同时更新渲染。
 * - 目的：为自动瞄准与自动开火提供动态位置支撑；物理与瞄准服务将订阅 unit/transform。
 */
import type { System, World } from '@domain/core/world' // 引入：系统/世界类型
import { PLAYER_COLLISION_RADIUS } from '@domain/systems/movement' // 引入：与玩家相同的碰撞半径，用作 AI 单位半径
import { EFFECTIVE_ATTACK_DIST } from './constants' // 引入：共享攻击有效距离，保证与开火一致

type TeamId = 'teamA' | 'teamB'

interface Walker { // 数据：被 AI 控制的单位
  id: string
  teamId: TeamId
  x: number
  z: number
}

const SPEED = 8 // 常量：AI 移动速度（m/s）固定为 8
const AGENT_RADIUS = PLAYER_COLLISION_RADIUS // 常量：AI 单位半径

export function aiWalkerSystem(): System { // 导出：AI 行走系统供装配使用
  console.log('[AI] 移动 AI 系统已初始化')

  const walkers = new Map<string, Walker>()
  const units = new Map<string, { id: string; teamId: TeamId; x: number; z: number }>() // 全部单位（含玩家）
  let obstacles: { x: number; z: number; scale: number }[] = []
  let bounds: { minX: number; maxX: number; minZ: number; maxZ: number } | null = null
  // 锁定目标映射：由 auto-fire 广播，保持“移动目标=攻击目标”
  const locks = new Map<string, { kind: 'enemy' | 'obstacle'; id: string } | undefined>()

  const isPlayer = (id: string) => id === 'player:1'

  const upsertWalker = (id: string, teamId: TeamId, x: number, z: number) => {
    if (isPlayer(id)) return
    walkers.set(id, { id, teamId, x, z })
    units.set(id, { id, teamId, x, z })
  }
  const removeWalker = (id: string) => {
    walkers.delete(id)
    units.delete(id)
  }

  const clampInBounds = (x: number, z: number): { x: number; z: number } => {
    if (!bounds) return { x, z }
    const margin = 0.5
    const cx = Math.min(bounds.maxX - margin, Math.max(bounds.minX + margin, x))
    const cz = Math.min(bounds.maxZ - margin, Math.max(bounds.minZ + margin, z))
    return { x: cx, z: cz }
  }

  const update: System['update'] = (dt, world: World) => {
    if (!(update as { sub?: boolean }).sub) {
      (update as { sub?: boolean }).sub = true

      // 订阅：场景重置，清空缓存，避免残留状态影响下一局
      world.bus.on('arena/reset', () => {
        walkers.clear()
        units.clear()
        obstacles = []
        bounds = null
        locks.clear()
        console.log('[AI] 收到场景重置，已清空单位与障碍缓存')
      })

      world.bus.on('arena/spawn-points', (e) => {
        const p = e.payload as { A?: { id?: string; x: number; z: number }[]; B?: { id?: string; x: number; z: number }[] }
        walkers.clear()
        units.clear()
        p?.A?.forEach((u, idx) => {
          const id = u.id ?? `teamA:${idx}`
          upsertWalker(id, 'teamA', u.x, u.z)
        })
        p?.B?.forEach((u, idx) => {
          const id = u.id ?? (idx === 0 ? 'player:1' : `teamB:${idx - 1}`)
          if (isPlayer(id)) {
            // 玩家不加入 walkers，但加入单位索引，以供敌方趋近/避障
            units.set(id, { id, teamId: 'teamB', x: u.x, z: u.z })
          } else {
            upsertWalker(id, 'teamB', u.x, u.z)
          }
        })
        console.log('[AI] 已同步行走单位', { count: walkers.size })
      })

      world.bus.on('arena/bounds', (e) => {
        const b = e.payload as { minX: number; maxX: number; minZ: number; maxZ: number } | undefined
        if (b) bounds = b
      })

      // 订阅：障碍列表，驱动简单双圆避障逻辑生效
      world.bus.on('arena/obstacles', (e) => {
        const list = (e as any).payload as { x?: number; z?: number; scale?: number }[] | undefined
        obstacles = Array.isArray(list)
          ? list
              .filter((o) => typeof o?.x === 'number' && typeof o?.z === 'number' && typeof o?.scale === 'number')
              .map((o) => ({ x: o.x as number, z: o.z as number, scale: o.scale as number }))
          : []
        console.log('[AI] 已同步障碍列表', { count: obstacles.length })
      })

      // 订阅：攻击锁定目标变更（来自 auto-fire）。保持“移动目标=当前攻击对象”。
      world.bus.on('ai/locked-target', (e) => {
        const p = e.payload as { shooterId?: string; teamId?: TeamId; lock?: { kind: 'enemy' | 'obstacle'; id: string } } | undefined
        const sid = p?.shooterId
        if (!sid || sid === 'player:1') return
        if (p?.lock) locks.set(sid, p.lock)
        else locks.set(sid, undefined)
        // console.log('[AI] 收到锁定目标变更', { shooterId: sid, lock: p?.lock })
      })

      world.bus.on('respawn/complete', (e) => {
        const p = e.payload as { unitId?: string; teamId?: TeamId; position?: { x: number; z: number } }
        if (!p?.unitId || !p.teamId || !p.position) return
        if (isPlayer(p.unitId)) return
        upsertWalker(p.unitId, p.teamId, p.position.x, p.position.z)
      })

      world.bus.on('entity/destroyed', (e) => {
        const id = (e.payload as { id?: string } | undefined)?.id
        if (!id) return
        removeWalker(id)
        locks.delete(id)
        if (id.startsWith('obstacle:')) {
          const idx = parseInt(id.split(':')[1] ?? '-1', 10)
          if (!Number.isNaN(idx) && obstacles[idx]) {
            // 以索引删除（障碍数组按 arena 广播顺序存储）
            obstacles.splice(idx, 1)
            // console.log('[AI] 已移除被销毁障碍的避障数据', { id })
          } else {
            // 若索引不可靠，尝试按近似坐标移除（忽略）
          }
        }
      })

      // 同步单位移动：维护 units 索引，便于其他单位趋近与避障
      world.bus.on('unit/transform', (e) => {
        const p = e.payload as { id?: string; teamId?: TeamId; position?: { x: number; z: number } } | undefined
        if (!p?.id || !p.position) return
        const u = units.get(p.id)
        if (u) {
          u.x = p.position.x
          u.z = p.position.z
        } else if (p.teamId) {
          units.set(p.id, { id: p.id, teamId: p.teamId, x: p.position.x, z: p.position.z })
        }
        const w = walkers.get(p.id)
        if (w) {
          w.x = p.position.x
          w.z = p.position.z
        }
      })
    }

    if (dt <= 0 || walkers.size === 0) return
    const render: any = world.ports.render

    // 构造敌方查找索引：按 teamId 过滤
    const byTeam: Record<TeamId, { id: string; x: number; z: number }[]> = { teamA: [], teamB: [] }
    units.forEach((u) => byTeam[u.teamId].push(u))

    walkers.forEach((w) => {
      const oppTeam: TeamId = w.teamId === 'teamA' ? 'teamB' : 'teamA'
      const list = byTeam[oppTeam]
      if (!list.length && obstacles.length === 0) return

      // 解析：当前移动目标（与攻击锁定一致）
      const currentLock = locks.get(w.id)
      let target: { x: number; z: number } | null = null
      if (currentLock?.kind === 'obstacle') {
        // 解析 obstacle:i 到坐标
        const idxStr = currentLock.id.split(':')[1]
        const idx = idxStr != null ? parseInt(idxStr, 10) : NaN
        if (!Number.isNaN(idx) && obstacles[idx]) target = { x: obstacles[idx].x, z: obstacles[idx].z }
      } else if (currentLock?.kind === 'enemy') {
        const en = units.get(currentLock.id)
        if (en) {
          const dx = en.x - w.x
          const dz = en.z - w.z
          const dist = Math.hypot(dx, dz)
          // 攻击对象是角色且离开攻击范围：不再追逐（不移动）
          if (dist <= EFFECTIVE_ATTACK_DIST + 1e-6) {
            target = null
          } else {
            // 不追逐（按规则），保持位置不动
            target = null
          }
        }
      }

      // 若无锁定，按“队列为空时”的三条规则选择移动目标
      if (!currentLock) {
        // 最近敌方
        let nearestEnemy: { x: number; z: number } | null = null
        let bestD2 = Infinity
        for (const t of list) {
          const dx = t.x - w.x
          const dz = t.z - w.z
          const d2 = dx * dx + dz * dz
          if (d2 < bestD2) { bestD2 = d2; nearestEnemy = { x: t.x, z: t.z } }
        }
        const enemyDist = nearestEnemy ? Math.sqrt(bestD2) : Infinity
        const enemyWithin = enemyDist <= EFFECTIVE_ATTACK_DIST + 1e-6
        if (!enemyWithin) {
          // 最近敌方在攻击距离外 → 若有障碍则去最近障碍，否则去最近敌方
          if (obstacles.length > 0) {
            let bestO2 = Infinity
            let bestO: { x: number; z: number } | null = null
            for (let i = 0; i < obstacles.length; i++) {
              const o = obstacles[i]
              const dx = o.x - w.x
              const dz = o.z - w.z
              const d2 = dx * dx + dz * dz
              if (d2 < bestO2) { bestO2 = d2; bestO = { x: o.x, z: o.z } }
            }
            target = bestO
          } else {
            target = nearestEnemy
          }
        } else {
          // 最近敌方在攻击距离内 → 选择最近敌方，但移动上保持不前进（等待攻击）
          target = null
        }
      }

      // 若无目标则不移动（保持朝向不变）
      const step = SPEED * dt
      let dirX = 0
      let dirZ = 1
      let nxPos = w.x
      let nzPos = w.z
      if (target) {
        const dx = target.x - w.x
        const dz = target.z - w.z
        const len = Math.hypot(dx, dz) || 1
        dirX = dx / len
        dirZ = dz / len
        nxPos = w.x + dirX * step
        nzPos = w.z + dirZ * step
      }

      // 简单双圆避障/分离：对障碍与其他单位做最小分离
      const minSep = 1e-3
      // 1) 障碍（半径 = scale*0.5）
      for (const o of obstacles) {
        const or = o.scale * 0.5
        const dx = nxPos - o.x
        const dz = nzPos - o.z
        const dist = Math.hypot(dx, dz)
        const minDist = or + AGENT_RADIUS
        if (dist < minDist && dist > minSep) {
          const push = (minDist - dist)
          nxPos += (dx / dist) * push
          nzPos += (dz / dist) * push
        }
      }
      // 2) 其他单位（半径 = AGENT_RADIUS）
      for (const u of units.values()) {
        if (u.id === w.id) continue
        const dx = nxPos - u.x
        const dz = nzPos - u.z
        const dist = Math.hypot(dx, dz)
        const minDist = AGENT_RADIUS + AGENT_RADIUS
        if (dist < minDist && dist > minSep) {
          const push = (minDist - dist)
          nxPos += (dx / dist) * push
          nzPos += (dz / dist) * push
        }
      }

      const clamped = clampInBounds(nxPos, nzPos)
      const mvx = clamped.x - w.x
      const mvz = clamped.z - w.z
      // 更新方向用于朝向展示
      const mvLen = Math.hypot(mvx, mvz) || 1
      dirX = mvx / mvLen
      dirZ = mvz / mvLen
      w.x = clamped.x
      w.z = clamped.z
      // 渲染与广播
      if (render?.applyEntity) {
        render.applyEntity(w.id, { position: { x: w.x, y: 0.5, z: w.z }, rotationY: Math.atan2(dirZ, dirX), scale: 1 })
      }
      world.bus.emit({ type: 'unit/transform', payload: { id: w.id, teamId: w.teamId, position: { x: w.x, z: w.z } } })
      // 更新单位索引位置（供其它 walker 参考本帧最新位置）
      units.set(w.id, { id: w.id, teamId: w.teamId, x: w.x, z: w.z })
    })
  }

  return { name: 'AIWalker', update }
}
